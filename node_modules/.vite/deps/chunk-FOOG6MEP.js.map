{
  "version": 3,
  "sources": ["../../three/examples/jsm/shaders/CopyShader.js", "../../three/examples/jsm/postprocessing/MaskPass.js", "../../three/examples/jsm/postprocessing/EffectComposer.js"],
  "sourcesContent": ["/**\r\n * @module CopyShader\r\n * @three_import import { CopyShader } from 'three/addons/shaders/CopyShader.js';\r\n */\r\n\r\n/**\r\n * Full-screen copy shader pass.\r\n *\r\n * @constant\r\n * @type {ShaderMaterial~Shader}\r\n */\r\nconst CopyShader = {\r\n\r\n\tname: 'CopyShader',\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'opacity': { value: 1.0 }\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tuniform float opacity;\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\r\n\t\t\tgl_FragColor = opacity * texel;\r\n\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { CopyShader };\r\n", "import { Pass } from './Pass.js';\r\n\r\n/**\r\n * This pass can be used to define a mask during post processing.\r\n * Meaning only areas of subsequent post processing are affected\r\n * which lie in the masking area of this pass. Internally, the masking\r\n * is implemented with the stencil buffer.\r\n *\r\n * ```js\r\n * const maskPass = new MaskPass( scene, camera );\r\n * composer.addPass( maskPass );\r\n * ```\r\n *\r\n * @augments Pass\r\n * @three_import import { MaskPass } from 'three/addons/postprocessing/MaskPass.js';\r\n */\r\nclass MaskPass extends Pass {\r\n\r\n\t/**\r\n\t * Constructs a new mask pass.\r\n\t *\r\n\t * @param {Scene} scene - The 3D objects in this scene will define the mask.\r\n\t * @param {Camera} camera - The camera.\r\n\t */\r\n\tconstructor( scene, camera ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t\t * The scene that defines the mask.\r\n\t\t *\r\n\t\t * @type {Scene}\r\n\t\t */\r\n\t\tthis.scene = scene;\r\n\r\n\t\t/**\r\n\t\t * The camera.\r\n\t\t *\r\n\t\t * @type {Camera}\r\n\t\t */\r\n\t\tthis.camera = camera;\r\n\r\n\t\t/**\r\n\t\t * Overwritten to perform a clear operation by default.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.clear = true;\r\n\r\n\t\t/**\r\n\t\t * Overwritten to disable the swap.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.needsSwap = false;\r\n\r\n\t\t/**\r\n\t\t * Whether to inverse the mask or not.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.inverse = false;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs a mask pass with the configured scene and camera.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\r\n\t * destination for the pass.\r\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\r\n\t * previous pass from this buffer.\r\n\t * @param {number} deltaTime - The delta time in seconds.\r\n\t * @param {boolean} maskActive - Whether masking is active or not.\r\n\t */\r\n\trender( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\r\n\r\n\t\tconst context = renderer.getContext();\r\n\t\tconst state = renderer.state;\r\n\r\n\t\t// don't update color or depth\r\n\r\n\t\tstate.buffers.color.setMask( false );\r\n\t\tstate.buffers.depth.setMask( false );\r\n\r\n\t\t// lock buffers\r\n\r\n\t\tstate.buffers.color.setLocked( true );\r\n\t\tstate.buffers.depth.setLocked( true );\r\n\r\n\t\t// set up stencil\r\n\r\n\t\tlet writeValue, clearValue;\r\n\r\n\t\tif ( this.inverse ) {\r\n\r\n\t\t\twriteValue = 0;\r\n\t\t\tclearValue = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\twriteValue = 1;\r\n\t\t\tclearValue = 0;\r\n\r\n\t\t}\r\n\r\n\t\tstate.buffers.stencil.setTest( true );\r\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\r\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\r\n\t\tstate.buffers.stencil.setClear( clearValue );\r\n\t\tstate.buffers.stencil.setLocked( true );\r\n\r\n\t\t// draw into the stencil buffer\r\n\r\n\t\trenderer.setRenderTarget( readBuffer );\r\n\t\tif ( this.clear ) renderer.clear();\r\n\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\trenderer.setRenderTarget( writeBuffer );\r\n\t\tif ( this.clear ) renderer.clear();\r\n\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t// unlock color and depth buffer and make them writable for subsequent rendering/clearing\r\n\r\n\t\tstate.buffers.color.setLocked( false );\r\n\t\tstate.buffers.depth.setLocked( false );\r\n\r\n\t\tstate.buffers.color.setMask( true );\r\n\t\tstate.buffers.depth.setMask( true );\r\n\r\n\t\t// only render where stencil is set to 1\r\n\r\n\t\tstate.buffers.stencil.setLocked( false );\r\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\r\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\r\n\t\tstate.buffers.stencil.setLocked( true );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * This pass can be used to clear a mask previously defined with {@link MaskPass}.\r\n *\r\n * ```js\r\n * const clearPass = new ClearMaskPass();\r\n * composer.addPass( clearPass );\r\n * ```\r\n *\r\n * @augments Pass\r\n */\r\nclass ClearMaskPass extends Pass {\r\n\r\n\t/**\r\n\t * Constructs a new clear mask pass.\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t\t * Overwritten to disable the swap.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default false\r\n\t\t */\r\n\t\tthis.needsSwap = false;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs the clear of the currently defined mask.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\r\n\t * destination for the pass.\r\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\r\n\t * previous pass from this buffer.\r\n\t * @param {number} deltaTime - The delta time in seconds.\r\n\t * @param {boolean} maskActive - Whether masking is active or not.\r\n\t */\r\n\trender( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\r\n\r\n\t\trenderer.state.buffers.stencil.setLocked( false );\r\n\t\trenderer.state.buffers.stencil.setTest( false );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { MaskPass, ClearMaskPass };\r\n", "import {\r\n\tClock,\r\n\tHalfFloatType,\r\n\tNoBlending,\r\n\tVector2,\r\n\tWebGLRenderTarget\r\n} from 'three';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\nimport { ShaderPass } from './ShaderPass.js';\r\nimport { ClearMaskPass, MaskPass } from './MaskPass.js';\r\n\r\n/**\r\n * Used to implement post-processing effects in three.js.\r\n * The class manages a chain of post-processing passes to produce the final visual result.\r\n * Post-processing passes are executed in order of their addition/insertion.\r\n * The last pass is automatically rendered to screen.\r\n *\r\n * This module can only be used with {@link WebGLRenderer}.\r\n *\r\n * ```js\r\n * const composer = new EffectComposer( renderer );\r\n *\r\n * // adding some passes\r\n * const renderPass = new RenderPass( scene, camera );\r\n * composer.addPass( renderPass );\r\n *\r\n * const glitchPass = new GlitchPass();\r\n * composer.addPass( glitchPass );\r\n *\r\n * const outputPass = new OutputPass()\r\n * composer.addPass( outputPass );\r\n *\r\n * function animate() {\r\n *\r\n * \tcomposer.render(); // instead of renderer.render()\r\n *\r\n * }\r\n * ```\r\n *\r\n * @three_import import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';\r\n */\r\nclass EffectComposer {\r\n\r\n\t/**\r\n\t * Constructs a new effect composer.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will\r\n\t * be used as the internal read and write buffers. If not given, the composer creates\r\n\t * the buffers automatically.\r\n\t */\r\n\tconstructor( renderer, renderTarget ) {\r\n\r\n\t\t/**\r\n\t\t * The renderer.\r\n\t\t *\r\n\t\t * @type {WebGLRenderer}\r\n\t\t */\r\n\t\tthis.renderer = renderer;\r\n\r\n\t\tthis._pixelRatio = renderer.getPixelRatio();\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\tconst size = renderer.getSize( new Vector2() );\r\n\t\t\tthis._width = size.width;\r\n\t\t\tthis._height = size.height;\r\n\r\n\t\t\trenderTarget = new WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType } );\r\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._width = renderTarget.width;\r\n\t\t\tthis._height = renderTarget.height;\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTarget1 = renderTarget;\r\n\t\tthis.renderTarget2 = renderTarget.clone();\r\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\r\n\r\n\t\t/**\r\n\t\t * A reference to the internal write buffer. Passes usually write\r\n\t\t * their result into this buffer.\r\n\t\t *\r\n\t\t * @type {WebGLRenderTarget}\r\n\t\t */\r\n\t\tthis.writeBuffer = this.renderTarget1;\r\n\r\n\t\t/**\r\n\t\t * A reference to the internal read buffer. Passes usually read\r\n\t\t * the previous render result from this buffer.\r\n\t\t *\r\n\t\t * @type {WebGLRenderTarget}\r\n\t\t */\r\n\t\tthis.readBuffer = this.renderTarget2;\r\n\r\n\t\t/**\r\n\t\t * Whether the final pass is rendered to the screen (default framebuffer) or not.\r\n\t\t *\r\n\t\t * @type {boolean}\r\n\t\t * @default true\r\n\t\t */\r\n\t\tthis.renderToScreen = true;\r\n\r\n\t\t/**\r\n\t\t * An array representing the (ordered) chain of post-processing passes.\r\n\t\t *\r\n\t\t * @type {Array<Pass>}\r\n\t\t */\r\n\t\tthis.passes = [];\r\n\r\n\t\t/**\r\n\t\t * A copy pass used for internal swap operations.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {ShaderPass}\r\n\t\t */\r\n\t\tthis.copyPass = new ShaderPass( CopyShader );\r\n\t\tthis.copyPass.material.blending = NoBlending;\r\n\r\n\t\t/**\r\n\t\t * The internal clock for managing time data.\r\n\t\t *\r\n\t\t * @private\r\n\t\t * @type {Clock}\r\n\t\t */\r\n\t\tthis.clock = new Clock();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Swaps the internal read/write buffers.\r\n\t */\r\n\tswapBuffers() {\r\n\r\n\t\tconst tmp = this.readBuffer;\r\n\t\tthis.readBuffer = this.writeBuffer;\r\n\t\tthis.writeBuffer = tmp;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds the given pass to the pass chain.\r\n\t *\r\n\t * @param {Pass} pass - The pass to add.\r\n\t */\r\n\taddPass( pass ) {\r\n\r\n\t\tthis.passes.push( pass );\r\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts the given pass at a given index.\r\n\t *\r\n\t * @param {Pass} pass - The pass to insert.\r\n\t * @param {number} index - The index into the pass chain.\r\n\t */\r\n\tinsertPass( pass, index ) {\r\n\r\n\t\tthis.passes.splice( index, 0, pass );\r\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the given pass from the pass chain.\r\n\t *\r\n\t * @param {Pass} pass - The pass to remove.\r\n\t */\r\n\tremovePass( pass ) {\r\n\r\n\t\tconst index = this.passes.indexOf( pass );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tthis.passes.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.\r\n\t *\r\n\t * @param {number} passIndex - The pass index.\r\n\t * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.\r\n\t */\r\n\tisLastEnabledPass( passIndex ) {\r\n\r\n\t\tfor ( let i = passIndex + 1; i < this.passes.length; i ++ ) {\r\n\r\n\t\t\tif ( this.passes[ i ].enabled ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Executes all enabled post-processing passes in order to produce the final frame.\r\n\t *\r\n\t * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes\r\n\t * its own time delta value.\r\n\t */\r\n\trender( deltaTime ) {\r\n\r\n\t\t// deltaTime value is in seconds\r\n\r\n\t\tif ( deltaTime === undefined ) {\r\n\r\n\t\t\tdeltaTime = this.clock.getDelta();\r\n\r\n\t\t}\r\n\r\n\t\tconst currentRenderTarget = this.renderer.getRenderTarget();\r\n\r\n\t\tlet maskActive = false;\r\n\r\n\t\tfor ( let i = 0, il = this.passes.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst pass = this.passes[ i ];\r\n\r\n\t\t\tif ( pass.enabled === false ) continue;\r\n\r\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\r\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\r\n\r\n\t\t\tif ( pass.needsSwap ) {\r\n\r\n\t\t\t\tif ( maskActive ) {\r\n\r\n\t\t\t\t\tconst context = this.renderer.getContext();\r\n\t\t\t\t\tconst stencil = this.renderer.state.buffers.stencil;\r\n\r\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\r\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\r\n\r\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\r\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.swapBuffers();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( MaskPass !== undefined ) {\r\n\r\n\t\t\t\tif ( pass instanceof MaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = true;\r\n\r\n\t\t\t\t} else if ( pass instanceof ClearMaskPass ) {\r\n\r\n\t\t\t\t\tmaskActive = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the internal state of the EffectComposer.\r\n\t *\r\n\t * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like\r\n\t * the one from the constructor. If set, it is used to setup the read and write buffers.\r\n\t */\r\n\treset( renderTarget ) {\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\tconst size = this.renderer.getSize( new Vector2() );\r\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\r\n\t\t\tthis._width = size.width;\r\n\t\t\tthis._height = size.height;\r\n\r\n\t\t\trenderTarget = this.renderTarget1.clone();\r\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\r\n\r\n\t\t}\r\n\r\n\t\tthis.renderTarget1.dispose();\r\n\t\tthis.renderTarget2.dispose();\r\n\t\tthis.renderTarget1 = renderTarget;\r\n\t\tthis.renderTarget2 = renderTarget.clone();\r\n\r\n\t\tthis.writeBuffer = this.renderTarget1;\r\n\t\tthis.readBuffer = this.renderTarget2;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},\r\n\t * this method honors the current pixel ration.\r\n\t *\r\n\t * @param {number} width - The width in logical pixels.\r\n\t * @param {number} height - The height in logical pixels.\r\n\t */\r\n\tsetSize( width, height ) {\r\n\r\n\t\tthis._width = width;\r\n\t\tthis._height = height;\r\n\r\n\t\tconst effectiveWidth = this._width * this._pixelRatio;\r\n\t\tconst effectiveHeight = this._height * this._pixelRatio;\r\n\r\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\r\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\r\n\r\n\t\tfor ( let i = 0; i < this.passes.length; i ++ ) {\r\n\r\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.\r\n\t * Setting the pixel ratio will automatically resize the composer.\r\n\t *\r\n\t * @param {number} pixelRatio - The pixel ratio to set.\r\n\t */\r\n\tsetPixelRatio( pixelRatio ) {\r\n\r\n\t\tthis._pixelRatio = pixelRatio;\r\n\r\n\t\tthis.setSize( this._width, this._height );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Frees the GPU-related resources allocated by this instance. Call this\r\n\t * method whenever the composer is no longer used in your app.\r\n\t */\r\n\tdispose() {\r\n\r\n\t\tthis.renderTarget1.dispose();\r\n\t\tthis.renderTarget2.dispose();\r\n\r\n\t\tthis.copyPass.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { EffectComposer };\r\n"],
  "mappings": "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",
  "names": []
}
